/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package net.stepniak.morenmodels.api

import net.stepniak.morenomodels.api.infrastructure.ClientException
import net.stepniak.morenomodels.api.model.*
import okhttp3.MediaType.Companion.toMediaType
import okhttp3.Request
import okhttp3.RequestBody
import okhttp3.RequestBody.Companion.toRequestBody
import org.junit.jupiter.api.assertThrows
import java.util.*
import kotlin.test.Test
import kotlin.test.assertEquals
import kotlin.test.assertNotNull
import kotlin.test.assertTrue

class PhotosIntegrationTest : BaseIntegrationTest() {
    @Test
    fun `creates a new photo and returns upload URL`() {
        // given
        val createdPhoto = api.createPhoto(
            NewPhoto(
                photoSlug = "test-photo-${UUID.randomUUID()}"
            )
        )
        assertNotNull(createdPhoto.photoId)
        assertNotNull(createdPhoto.uploadUri)
        assertNotNull(createdPhoto.photoSlug)

        // when
        uploadPhotoFromDisk(createdPhoto, small = false)

        // then
        val receivedPhoto = api.getPhoto(createdPhoto.photoSlug)
        assertNotNull(receivedPhoto.photoId)
        assertNotNull(receivedPhoto.photoSlug)
        assertNotNull(receivedPhoto.uri)
        assertNotNull(receivedPhoto.version)
        assertNotNull(receivedPhoto.width)
        assertNotNull(receivedPhoto.height)
        assert(downloadPhoto(receivedPhoto) > 420)

        // cleanup
        api.archivePhoto(createdPhoto.photoSlug, delete = true)
    }

    @Test
    fun `properly handles not existing photos when getting one`() {
        // given, when
        val ex = assertThrows<ClientException> {
            api.getPhoto(NON_EXISTENT_SLUG)
        }
        // then
        assertEquals(404, ex.statusCode)
    }

    @Test
    fun `properly handles not existing photos deleting getting one`() {
        // given, when
        val ex = assertThrows<ClientException> {
            api.archivePhoto(NON_EXISTENT_SLUG, true)
        }
        // then
        assertEquals(404, ex.statusCode)
    }


    @Test
    fun `validates create photo parameters`() {
        // given, when
        val ex = assertThrows<ClientException> {
            api.createPhoto(NewPhoto(INVALID_SLUG))
        }
        // then
        assertEquals(400, ex.statusCode)
    }

    @Test
    fun `validates list photos parameters`() {
        // given, when
        val ex = assertThrows<ClientException> {
            api.listPhotos(
                nextToken = "3".repeat(513),
                pageSize = 1001,
                modelSlug = INVALID_SLUG,
                showArchived = null
            )
        }
        // then
        assertEquals(400, ex.statusCode)
    }

    @Test
    fun `validates get photo parameters`() {
        // given, when, then
        val ex = assertThrows<ClientException> {
            api.getPhoto(
                photoSlug = INVALID_SLUG
            )
        }
        // then
        assertEquals(400, ex.statusCode)
    }

    @Test
    fun `validates archive photo parameters`() {
        val ex = assertThrows<ClientException> {
            api.archivePhoto(photoSlug = INVALID_SLUG, delete = false)
        }
        // then
        assertEquals(400, ex.statusCode)
    }

    @Test
    fun `erases a photo`() {
        // given
        val photo = createAndUploadPhoto()

        // when
        api.archivePhoto(photo.photoSlug, true)

        // then
        assertThrows<Exception> {
            api.getPhoto(photo.photoSlug)
        }
    }

    @Test
    fun `archives a photo`() {
        // given
        val photo = createAndUploadPhoto()

        // when
        api.archivePhoto(photo.photoSlug, false)

        // then
        assertTrue(api.getPhoto(photo.photoSlug).archived)

        // cleanup
        api.archivePhoto(photo.photoSlug, true)
    }

    @Test
    fun `lists photos and paginates`() {
        // given
        val newModel = NewModel(
            modelSlug = "test-model-${UUID.randomUUID()}",
            givenName = "Konrad",
            familyName = "Moreno"
        )
        val model = api.createModel(newModel)
        val pageSize = 5
        val numberOfCreatedPhotos = 11
        val createdPhotos = (1..11).map {
            createAndUploadPhoto(true, modelSlug = model.modelSlug)
        }.toList()

        var seenPages = 0
        var seenPhotos = 0
        var photos: Photos? = null
        // when
        do {
            photos = api.listPhotos(
                nextToken = photos?.metadata?.nextToken,
                pageSize,
                showArchived = null,
                modelSlug = model.modelSlug,
            )

            seenPages += 1
            seenPhotos += photos.items.size

            photos.items.forEach {
                assertNotNull(it.photoId)
                assertNotNull(it.photoSlug)
                assertNotNull(it.version)
                assertNotNull(it.uri)
            }

        } while (photos?.metadata?.nextToken != null)

        // then
        assertTrue {
            seenPhotos == numberOfCreatedPhotos
                    && seenPages == 3
        }

        // cleanup
        createdPhotos.forEach { api.archivePhoto(it.photoSlug, true) }
        api.archiveModel(model.modelSlug, true)
    }

    @Test
    fun `lists archived photos and paginates`() {
        // given
        val newModel = NewModel(
            modelSlug = "test-model-${UUID.randomUUID()}",
            givenName = "Konrad",
            familyName = "Moreno"
        )
        val model = api.createModel(newModel)
        val pageSize = 5
        val numberOfCreatedPhotos = 11
        val createdPhotos = (1..11).map {
            createAndUploadPhoto(true, model.modelSlug)
        }.toList()
        createdPhotos.forEach { api.archivePhoto(it.photoSlug, delete = false) }

        var seenPages = 0
        var seenPhotos = 0
        var photos: Photos? = null
        // when
        do {
            photos = api.listPhotos(
                nextToken = photos?.metadata?.nextToken,
                pageSize,
                showArchived = true,
                modelSlug = model.modelSlug,
            )

            seenPages += 1
            seenPhotos += photos.items.size

            photos.items.forEach {
                assertNotNull(it.photoId)
                assertNotNull(it.photoSlug)
                assertNotNull(it.version)
                assertNotNull(it.uri)
            }

        } while (photos?.metadata?.nextToken != null)

        // then
        assertTrue {
            seenPhotos == numberOfCreatedPhotos
                    && seenPages == 3
        }

        // cleanup
        createdPhotos.forEach { api.archivePhoto(it.photoSlug, true) }
        api.archiveModel(model.modelSlug, true)
    }

    @Test
    fun `lists photos filtered by a model`() {
        // given
        val model = api.createModel(NewModel(
            "test-model-${UUID.randomUUID()}",
            givenName = "Konrad",
            familyName = "Moreno"
        ))
        val createdPhoto = createAndUploadPhoto(true, model.modelSlug)

        // when
        val photos = api.listPhotos(
            modelSlug = model.modelSlug,
            nextToken = null,
            showArchived = null,
            pageSize = null
        )

        // then
        assertEquals(1, photos.items.size)

        // cleanup
        api.archivePhoto(createdPhoto.photoSlug, true)
        api.archiveModel(model.modelSlug, true)
    }

    private fun createAndUploadPhoto(small: Boolean = true, modelSlug: String? = null): CreatedPhoto {
        val createdPhoto = api.createPhoto(
            NewPhoto(
                photoSlug = "test-photo-${UUID.randomUUID()}",
                modelSlug = modelSlug
            )
        )

        uploadPhotoFromDisk(createdPhoto, small)
        return createdPhoto
    }

    private fun uploadPhotoFromDisk(createdPhoto: CreatedPhoto, small: Boolean = true) {
        val photoFilePath = if (small) "/small-photo.png" else "/big-photo.jpg"
        val photoMediaType = if (small) "image/png".toMediaType() else "image/jpg".toMediaType()


        val response = httpClient.newCall(
            Request.Builder()
                .url(createdPhoto.uploadUri.toURL())
                .method(
                    "PUT", body = RequestBody.javaClass.getResource(photoFilePath)
                        !!.readBytes()
                        !!.toRequestBody(photoMediaType)
                )
                .build()
        ).execute()

        assertTrue { response.isSuccessful }
    }

    private fun downloadPhoto(photo: Photo): Int {
        val response = httpClient.newCall(
            Request.Builder()
                .url(photo.uri!!.toURL())
                .method("GET", null)
                .build()
        ).execute()

        return response.body!!.bytes().size
    }

    companion object {
        private const val INVALID_SLUG = "#4_(*!@#*/"
        private const val NON_EXISTENT_SLUG = "non-ex3st1nt-sl4g"
    }
}
